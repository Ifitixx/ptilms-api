// ptilms-api/services/AuthService.js
const jwt = require('jsonwebtoken');
const {
  UnauthorizedError,
  ConflictError,
  NotFoundError,
  ValidationError,
  BadRequestError,
} = require('../utils/errors');
const logger = require('../utils/logger');
const config = require('../config/config');
const { addToken, isBlacklisted } = require('../utils/tokenBlacklist');
const { v4: uuidv4 } = require('uuid');
const { ROLES, USER_SELECTABLE_ROLES } = require('../config/constants');

class AuthService {
  constructor({ userRepository, roleRepository }) {
    this.userRepository = userRepository;
    this.roleRepository = roleRepository;
  }

  async register(userData) {
    try {
      const { email, username, password, role } = userData;

      // Check if the user already exists
      const existingUser = await this.userRepository.findByEmailOrUsername(email, username);
      if (existingUser) {
        throw new ConflictError('User with this email or username already exists');
      }

      // Validate the user-selected role (case-insensitive)
      if (!USER_SELECTABLE_ROLES.includes(role.toLowerCase())) {
        throw new BadRequestError(`Invalid role selected. Allowed roles are: ${USER_SELECTABLE_ROLES.join(', ')}`);
      }

      // Get the role
      const userRole = await this.roleRepository.getRoleByName(role);
      if (!userRole) {
        throw new BadRequestError(`Invalid role selected. Role '${role}' not found in the database.`);
      }

      // Create the user
      const user = await this.userRepository.createUser({
        email,
        username,
        password,
        roleId: userRole.id,
      });

      return user;
    } catch (error) {
      logger.error(`Error in register: ${error.message}`);
      throw error;
    }
  }

  async login(email, password) {
    try {
      const user = await this.userRepository.getUserByEmail(email);
      if (!user) {
        throw new UnauthorizedError('Invalid credentials');
      }

      const isPasswordValid = await user.verifyPassword(password);
      if (!isPasswordValid) {
        throw new UnauthorizedError('Invalid credentials');
      }
      const roleName = user.role ? user.role.name : null;

      const accessToken = jwt.sign(
        { userId: user.id, email: user.email, role: roleName },
        config.jwt.secret,
        { expiresIn: config.jwt.accessExpiry }
      );

      const refreshToken = jwt.sign(
        { userId: user.id, email: user.email, role: roleName },
        config.jwt.refreshSecret,
        { expiresIn: config.jwt.refreshExpiry }
      );

      return { accessToken, refreshToken, user };
    } catch (error) {
      logger.error(`Error in login: ${error.message}`);
      throw error;
    }
  }

  async refreshToken(refreshToken) {
    try {
      if (!refreshToken) throw new BadRequestError('Refresh token required');

      const decoded = jwt.verify(refreshToken, config.jwt.refreshSecret);
      const user = await this.userRepository.getUserById(decoded.userId);

      if (!user) throw new UnauthorizedError('User not found');
      if (await isBlacklisted(refreshToken)) {
        throw new UnauthorizedError('Token revoked');
      }

      // Generate new tokens
      const accessToken = jwt.sign(
        { userId: user.id, email: user.email, role: user.role?.name },
        config.jwt.secret,
        { expiresIn: config.jwt.accessExpiry }
      );

      const newRefreshToken = jwt.sign(
        { userId: user.id, email: user.email, role: user.role?.name },
        config.jwt.refreshSecret,
        { expiresIn: config.jwt.refreshExpiry }
      );

      // Blacklist old refresh token
      const remainingTime = Math.floor((decoded.exp * 1000 - Date.now()) / 1000);
      if (remainingTime > 0) {
        await addToken(refreshToken, remainingTime);
      }

      return { accessToken, refreshToken: newRefreshToken };
    } catch (error) {
      logger.error(`Refresh Token Error: ${error.message}`);
      if (error instanceof jwt.TokenExpiredError) {
        throw new UnauthorizedError('Refresh token expired');
      }
      if (error instanceof jwt.JsonWebTokenError) {
        throw new UnauthorizedError('Invalid refresh token');
      }
      throw error;
    }
  }

  async forgotPassword(email) {
    try {
      const user = await this.userRepository.getUserByEmail(email);
      if (!user) {
        throw new NotFoundError('User not found');
      }

      const resetToken = uuidv4();
      const resetTokenExpiry = new Date(Date.now() + 3600000); // 1 hour

      await this.userRepository.updateUser(user.id, { resetToken, resetTokenExpiry });

      // TODO: Send email with reset link
      logger.info(`Password reset token for ${email}: ${resetToken}`);
    } catch (error) {
      logger.error(`Error in forgotPassword: ${error.message}`);
      throw error;
    }
  }

  async resetPassword(token, newPassword) {
    try {
      const user = await this.userRepository.userModel.scope('withSensitive').findOne({ where: { resetToken: token } });
      if (!user || user.resetTokenExpiry < new Date()) {
        throw new UnauthorizedError('Invalid or expired token');
      }

      await this.userRepository.updateUser(user.id, { password: newPassword, resetToken: null, resetTokenExpiry: null });
      // TODO: Send email confirmation
      logger.info(`Password reset for user ${user.email}`);
    } catch (error) {
      logger.error(`Error in resetPassword: ${error.message}`);
      throw error;
    }
  }
}

module.exports = AuthService;